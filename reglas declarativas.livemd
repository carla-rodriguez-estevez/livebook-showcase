# Sistema de reglas declarativas con l贸gica funcional

## Introducci贸n al enfoque declarativo y funcional

Queremos expresar l贸gica de negocio como un conjunto de reglas legibles, modificables y componibles, sin recurrir a estructuras de control como `if`, `cond` o `case`. En lugar de eso, modelaremos:

* **Hechos** como mapas de informaci贸n disponibles.
* **Reglas** como funciones puras que declaran su intenci贸n.
* **Evaluaci贸n** como una composici贸n de esas reglas sobre los hechos.

Este enfoque mejora la mantenibilidad y permite separar reglas de procesamiento.

## Representaci贸n de hechos y reglas

```elixir
# Modelo de un hecho: informaci贸n disponible en un momento dado
hecho = %{
  edad: 25,
  rol: :admin,
  activo: true
}

# Modelo de una regla: funci贸n pura que recibe un hecho y 
# devuelve {:ok, mensaje} o {:error, mensaje}
regla_es_adulto = fn %{edad: edad} ->
  if edad >= 18, do: {:ok, "Es mayor de edad"}, else: {:error, "Es menor de edad"}
end

regla_es_admin = fn %{rol: rol} ->
  if rol == :admin, do: {:ok, "Es administrador"}, else: {:error, "No es admin"}
end

```

## Sistema de evaluaci贸n de reglas

```elixir
# Funci贸n que aplica una lista de reglas a un hecho y agrupa resultados
defmodule MotorReglas do
  def evaluar(hecho, reglas) do
    Enum.map(reglas, fn regla -> regla.(hecho) end)
  end

  def filtrar_ok(resultados), do: Enum.filter(resultados, &match?({:ok, _}, &1))
  def filtrar_errores(resultados), do: Enum.filter(resultados, &match?({:error, _}, &1))
end

#  Probar
reglas = [regla_es_adulto, regla_es_admin]
resultados = MotorReglas.evaluar(hecho, reglas)
IO.inspect(resultados, label: " Resultados")

```

## Composici贸n y control de flujo funcional elixir

```elixir
defmodule Evaluador do
  def validar(hecho, reglas) do
    resultados = MotorReglas.evaluar(hecho, reglas)

    if Enum.all?(resultados, fn
      {:ok, _} -> true
      _ -> false
    end) do
      {:ok, Enum.map(resultados, fn {:ok, msg} -> msg end)}
    else
      errores = MotorReglas.filtrar_errores(resultados)
      {:error, Enum.map(errores, fn {:error, msg} -> msg end)}
    end
  end
end

#  Probar
Evaluador.validar(%{edad: 17, rol: :user}, reglas)

```

## Casos de uso: validaciones y l贸gica de negocio

```elixir
# Nueva regla: requiere usuario activo
regla_activo = fn %{activo: activo} ->
  if activo, do: {:ok, "Usuario activo"}, else: {:error, "Usuario inactivo"}
end

# Escenario de login
usuario = %{edad: 34, rol: :user, activo: false}
reglas_login = [regla_es_adulto, regla_activo]

Evaluador.validar(usuario, reglas_login)

```

## Extensiones 煤tiles

Hasta ahora, hemos visto reglas como simples funciones. Pero en sistemas declarativos complejos, eso no es suficiente. Necesitamos que las reglas no solo verifiquen condiciones, sino que tambi茅n puedan describirse a s铆 mismas, ser ordenadas, y ser manipulables como datos.

En esta celda introducimos un patr贸n funcional muy poderoso:
Convertimos cada regla en una estructura de datos enriquecida.

 Cada Regla contiene:

**nombre**: una descripci贸n humana legible para trazabilidad o auditor铆a.

**prioridad**: un n煤mero que nos permite ordenarlas y ejecutar primero las m谩s cr铆ticas.

**verificador**: la funci贸n que eval煤a el hecho.

Esta forma de modelar reglas desacopla la l贸gica de negocio de su ejecuci贸n y habilita:

* Reglas configurables desde archivos externos.

* Cambios din谩micos de reglas en tiempo real.

* Depuraci贸n y trazabilidad mejoradas.

En resumen: esta celda convierte funciones en conocimiento estructurado. Lo que antes eran solo l铆neas de c贸digo ahora pueden formar un sistema declarativo autoorganizado.

```elixir
defmodule Regla do
  defstruct [:nombre, :prioridad, :verificador]

  def nueva(nombre, prioridad, verificador) do
    %__MODULE__{nombre: nombre, prioridad: prioridad, verificador: verificador}
  end

  def ejecutar(%__MODULE__{nombre: nombre, verificador: vf}, hecho) do
    if vf.(hecho), do: {:ok, nombre}, else: {:error, nombre}
  end
end

reglas_ext = [
  Regla.nueva("Mayor de edad", 1, fn %{edad: edad} -> edad >= 18 end),
  Regla.nueva("Admin", 2, fn %{rol: rol} -> rol == :admin end)
]

for regla <- reglas_ext do
  Regla.ejecutar(regla, %{edad: 20, rol: :user})
end

```

Esta idea de reglas como datos nos va a permitir aplicar ordenaci贸n, filtrado, o incluso agrupaci贸n por tipo de regla. Nos acercamos a tener un motor de inferencia funcional, algo que se encuentra en el n煤cleo de muchos **sistemas expertos**.

## Conclusi贸n

* Un sistema de reglas declarativas permite una l贸gica de negocio m谩s transparente, composable y testable.
* Elixir, con funciones puras y estructuras inmutables, es ideal para este enfoque.
* Puedes extender el sistema f谩cilmente: a帽adir trazabilidad, persistencia, UI para edici贸n de reglas, etc.

---

 Este enfoque es 煤til en sistemas de autorizaci贸n, validaciones, motores de decisi贸n, y simulaciones basadas en reglas.
