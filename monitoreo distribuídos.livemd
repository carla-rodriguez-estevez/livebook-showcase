# Monitoreo distribuido en tiempo real con Elixir: Control de una constelaci√≥n de sat√©lites

```elixir
Mix.install([
  {:kino, "~> 0.12"},
  {:vega_lite, "~> 0.1.11"},
  {:kino_vega_lite, "~> 0.1.8"}
])
```

## Concepto

Vamos a simular una red de sat√©lites orbitando la Tierra, donde cada sat√©lite es un proceso que transmite m√©tricas (temperatura del n√∫cleo, se√±al, posici√≥n orbital, bater√≠a...). El sistema podr√°:

Visualizar cada sat√©lite en un mapa 2D del globo con coordenadas.

Mostrar su estado vital (con color verde/amarillo/rojo seg√∫n anomal√≠as).

Supervisar y reiniciar sat√©lites ca√≠dos (simulaci√≥n de fallos).

Producir logs y alertas visuales de comportamiento an√≥malo.

Incluir una vista tipo "sala de control" para ver todo en tiempo real.

<!-- livebook:{"break_markdown":true} -->

üõ∞Ô∏è Monitoreo distribuido en tiempo real con Elixir

**¬øQu√© veremos?**  
Simularemos una constelaci√≥n de sat√©lites orbitando y enviando telemetr√≠a en tiempo real. Cada sat√©lite ser√° un proceso concurrente, y visualizaremos en Livebook su estado y posici√≥n.

Este proyecto demostrar√° el poder de Elixir para sistemas de monitoreo distribuidos, altamente concurrentes, con una interfaz visual e interactiva.

## Monitor central

Recibe todos los datos y actualiza un `Kino.Frame` con la telemetr√≠a en tiempo real.

```elixir
defmodule Monitor do
  use GenServer

  def start_link(_) do
    GenServer.start_link(__MODULE__, %{data: []}, name: __MODULE__)
  end

  def receive_data(id, data) do
    GenServer.cast(__MODULE__, {:nuevo_dato, id, data})
  end

  def init(state) do
    {:ok, Map.put(state, :frame, Kino.Frame.new())}
  end

  def handle_cast({:nuevo_dato, id, data}, state) do
    new_data = [%{id: id, data: data} | state.data] |> Enum.take(50)

    markdown =
      new_data
      |> Enum.map(fn %{id: id, data: data} ->
        "- **#{id}** - Pos: (#{elem(data.position, 0)}, #{elem(data.position, 1)}), Temp: #{data.temperature}¬∞C, ‚ö° #{data.battery}%"
      end)
      |> Enum.join("\n")

    Kino.Frame.clear(state.frame)
    Kino.Frame.append(state.frame, Kino.Markdown.new("""
    ### üì° Telemetr√≠a de sat√©lites (√∫ltimos datos):
    #{markdown}
    """))

    {:noreply, %{state | data: new_data}}
  end
end

{:ok, monitor_pid} = Monitor.start_link(nil)

monitor_pid |> :sys.get_state() |> Map.get(:frame)

```

## Representaci√≥n de la constelaci√≥n

Vamos a modelar 10 sat√©lites como procesos GenServer que mandan datos peri√≥dicamente. Estos datos se centralizan en un proceso de monitoreo que los agrupa y visualiza.

```elixir
defmodule Satelite do
  use GenServer

  def start_link(id) do
    GenServer.start_link(__MODULE__, %{id: id}, name: via(id))
  end

  defp via(id), do: {:via, Registry, {:satelites, id}}

  def init(state) do
    send(self(), :emitir)
    {:ok, Map.put(state, :data, [])}
  end

  def handle_info(:emitir, state) do
    data = %{
      timestamp: DateTime.utc_now(),
      position: {Enum.random(0..100), Enum.random(0..100)},
      temperature: :rand.uniform(50) + 10,
      battery: Enum.random(30..100)
    }

    Monitor.receive_data(state.id, data)
    Process.send_after(self(), :emitir, 1000)
    {:noreply, %{state | data: [data | state.data] |> Enum.take(10)}}
  end

  def handle_call(:get_data, _from, state) do
    {:reply, state.data, state}
  end

end

```

## Iniciar la constelaci√≥n

```elixir
{:ok, _} = Registry.start_link(keys: :unique, name: :satelites)

for id <- 1..10 do
  Satelite.start_link("SAT-#{id}")
end

```

## Visualizaci√≥n gr√°fica de posiciones

Mostrar las posiciones en un gr√°fico VegaLite animado y real.

```elixir
graph_data = Kino.DataTable.new([])

frame_posiciones = Kino.Frame.new()
Kino.render(frame_posiciones)

posicion_fn = fn ->
  data =
    :satelites
    |> Registry.select([{{:"$1", :_, :_}, [], [:"$1"]}])
    |> Enum.map(fn id ->
      [last | _] = GenServer.call({:via, Registry, {:satelites, id}}, :get_data)
      %{id: id, x: elem(last.position, 0), y: elem(last.position, 1)}
    end)

  vl =
    VegaLite.new()
    |> VegaLite.data_from_values(data)
    |> VegaLite.encode_field(:x, "x")
    |> VegaLite.encode_field(:y, "y")
    |> VegaLite.encode_field(:text, "id")
    |> VegaLite.mark(:circle)
    |> then(fn vl ->                # Aumentar tama√±o del gr√°fico
    %{vl | spec: Map.merge(vl.spec, %{"width" => 1000, "height" => 500})}
  end)

  Kino.Frame.clear(frame_posiciones)
  Kino.Frame.append(frame_posiciones, Kino.VegaLite.new(vl))
end

:timer.send_interval(2000, self(), :update_graph)

receive do
  :update_graph -> posicion_fn.()
end

```

## Interacci√≥n: inspeccionar un sat√©lite

Permitir elegir un sat√©lite y ver sus √∫ltimos datos.

```elixir
opciones = Enum.map(1..10, &{"SAT-#{&1}", "Sat√©lite #{&1}"})
selector = Kino.Input.select("Selecciona un sat√©lite", opciones)

Kino.render(selector)

detalle = Kino.Frame.new()
Kino.render(detalle)

Kino.listen(selector, fn %{value: id} ->
  IO.puts("üîò Bot√≥n presionado")

  #id = Kino.Input.get(selector)
  IO.puts("Click #{id}")

  case GenServer.call({:via, Registry, {:satelites, id}}, :get_data) do
     datos  ->
      resumen =
        datos
        |> Enum.map(fn d ->
          "- #{d.timestamp} ‚Üí Temp: #{d.temperature}¬∞C, ‚ö° #{d.battery}%, Pos: #{inspect(d.position)}"
        end)
        |> Enum.join("\n")

      #IO.puts("Click #{resumen}")

      Kino.Frame.clear(detalle)

      Kino.Frame.append(detalle, Kino.Markdown.new("""
      ### üìÑ Historial de `#{id}`

      #{resumen}
      """))

    _ ->
      Kino.Frame.clear(detalle)
      Kino.Frame.append(detalle, Kino.Markdown.new("‚ùå No se encontr√≥ el sat√©lite `#{id}`."))
  end
end)

```

## ‚úÖ Conclusi√≥n

Hemos creado una simulaci√≥n distribuida en Elixir que:

* Lanza m√∫ltiples procesos representando sat√©lites.
* Cada uno reporta su estado peri√≥dicamente.
* Un monitor central coordina y visualiza sus datos.
* Livebook sirve como panel visual interactivo.

üöÄ ¬°Este es solo el comienzo! Podr√≠as conectar sensores reales, simular fallos, o exportar la telemetr√≠a como m√©tricas Prometheus.
